// // //
// // //
// // // ==============================================
// // //     -  Створити функцію конструктор для об'єкту який описує теги
// //
// // // Властивості
// // // -назва тегу
// // // - опис його дій
// // // - масив з атрибутами (2-3 атрибути максимум)
//
// function Teg(titleOfTag, action, atribut1, atribut2) {
//     this.titleOfTag = titleOfTag;
//     this.action = action;
//     this.attrs = [atribut1, atribut2];
// };
//
//
// //
// //
// // // Кожен атрибут описати як окремий який буде містити
// // // -назву атрибуту
// // // -опис дії атрибуту
// // // інформацію брати з htmlbook.ru
// // //
// function Atributs(titleOfAttr, actionOfAttr) {
//     this.titleOfAttr = titleOfAttr;
//     this.actionOfAttr = actionOfAttr;
// }
//
// //
// //
// // // Таким чином описати теги
//
//
// // -a
//
// // let atributs = new Atributs('accesskey','Активация ссылки с помощью комбинации клавиш.');
// // let atributs2 = new Atributs('coords','Устанавливает координаты активной области.');
// // let a = new Teg('<a>','Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В' +
// //     ' зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется' +
// //     ' закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая' +
// //     ' указывает на якорь, происходит переход к закладке внутри веб-страницы.',atributs,atributs2);
// // console.log(a);
//
//
// // // -div
//
// // let atributs = new Atributs('align','Задает выравнивание содержимого тега <div>.');
// // let atributs2 = new Atributs('title\n','Добавляет всплывающую подсказку к содержимому.');
// // let div = new Teg('div',"Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью" +
// //     " изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз" +
// //     " стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с" +
// //     " именем селектора.",atributs,atributs2);
// //
//
// // // -h1
// // let atributs = new Atributs('align','Определяет выравнивание заголовка.');
// // let atributs2 = new Atributs('disabled','Заблокировать для доступа элемент списка.')
// //
// // let h1 = new Teg("h1","HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.",atributs,atributs2);
// // console.log(h1);
// //
//
// // // -span
//
// // let atributs = new Atributs('accesskey','Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.');
// // let atributs2 = new Atributs('class','Определяет имя класса, которое позволяет связать тег со стилевым оформлением.');
// // let span = new Teg('span',"Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных" +
// //     " элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других" +
// //     " тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой" +
// //     " буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.",atributs,atributs2);
// // // -input
//
// // let atributs = new Atributs('accept','Устанавливает фильтр на типы файлов, которые вы можете отправить через поле' +
// //     ' загрузки файлов.');
// // let atributs2 = new Atributs('class','Определяет имя класса, которое позволяет связать тег со стилевым оформлением.');
// //
// //
// // let input = new Teg('input',"Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные" +
// //     " элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript.",atributs,atributs2);
// //
// // // -form
//
// // let atributs = new Atributs('class','Определяет имя класса, которое позволяет связать тег со стилевым оформлением.');
// // let atributs2 = new Atributs('contenteditable','Сообщает, что элемент доступен для редактирования пользователем.');
// // let form = new Teg('form',"Связывает поле с формой по её идентификатору. Такая связь необходима в случае, когда поле" +
// //     " располагается за пределами <form>, например, при создании её программно или по соображениям дизайна.",atributs,atributs2);
// //
// // console.log(form);
// // // -option
//
// // let atributs = new Atributs('disabled','Заблокировать для доступа элемент списка.');
// // let atributs2 = new Atributs('label','Указание метки пункта списка..');
// // let option = new Teg('option',"Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера" +
// //     " <select>." +
// //     " Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.",atributs,atributs2);
// // // -select
//
// let atributs = new Atributs('accesskey', 'Позволяет перейти к списку с помощью некоторого сочетания клавиш.');
// let atributs2 = new Atributs('autofocus', 'Устанавливает, что список получает фокус после загрузки страницы.');
// let select = new Teg('select', "Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося" +
//     " списка, а также" +
//     " список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.", atributs, atributs2);
// // Приклад результату
// // {
// //     titleOfTag: 'area',
// //         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
// //     attrs: [
// //     {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
// //     {/*some props and values*/},
// //     {/*...*/},
// //     {/*...*/},
// // ]
// //
// // }
// // ==============================================
// //
// //
// // ==============================================
// //     -  Створити класс  для об'єкту який описує теги
// // Властивості
// // -назва тегу
// // - опис його дій
// // - масив з атрибутами (2-3 атрибути максимум)
//
// // class Teg {
// //     constructor(titleOfTag, action) {
// //         this.titleOfTag = titleOfTag;
// //         this.action = action;
// //         this.attrs = [];
// //     };
// //
// //
// //     addMas(object){
// //         this.attrs.push(object);
// //     }
// //
// // }
// // Кожен атрибут описати як окремий який буде містити
// // -назву атрибуту
// // -опис дії атрибуту
// // інформацію брати з htmlbook.ru
// //
//
//
// // function Atributs(titleOfAttr, actionOfAttr) {
// //     this.titleOfAttr = titleOfAttr;
// //     this.actionOfAttr = actionOfAttr;
// // }
// //
// //
// // // Таким чином описати теги
// // // -a
// //
// // let a = new Teg('<a>','Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В' +
// //     ' зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы.')
// // let atributs = new Atributs('accesskey','Активация ссылки с помощью комбинации клавиш.')
// // let atributs2 = new Atributs('coords','Устанавливает координаты активной области.')
// // let atributs3 = new Atributs('download','Предлагает скачать указанный по ссылке файл.')
// // a.addMas(atributs);
// // a.addMas(atributs2);
// // a.addMas(atributs3);
// //
// // // -div
// // let div = new Teg("Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью" +
// //     " изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.")
// // let atributs = new Atributs('align','Задает выравнивание содержимого тега <div>.')
// // let atributs2 = new Atributs('title\n','Добавляет всплывающую подсказку к содержимому.')
// // div.addMas(atributs);
// // div.addMas(atributs2);
// //
// // // -h1
// //
// // let h1 = new Teg("HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.")
// // let atributs = new Atributs('align','Определяет выравнивание заголовка.')
// // h1.addMas(atributs);
// //
// // // -span
// // let span = new Teg("Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.")
// // let atributs = new Atributs('accesskey','Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.')
// // let atributs2 = new Atributs('class','Определяет имя класса, которое позволяет связать тег со стилевым оформлением.')
// // let atributs3 = new Atributs('contenteditable','Сообщает, что элемент доступен для редактирования пользователем.')
// // span.addMas(atributs);
// // span.addMas(atributs2);
// // span.addMas(atributs3);
// //
// // // -input
// // let input = new Teg("Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript.")
// // let atributs = new Atributs('accept','Устанавливает фильтр на типы файлов, которые вы можете отправить через поле' +
// //     ' загрузки файлов.');
// // let atributs2 = new Atributs('class','Определяет имя класса, которое позволяет связать тег со стилевым оформлением.')
// // let atributs3 = new Atributs('contenteditable','Сообщает, что элемент доступен для редактирования пользователем.')
// // input.addMas(atributs);
// // input.addMas(atributs2);
// // input.addMas(atributs3);
// //
// // // -form
// // let form = new Teg("Связывает поле с формой по её идентификатору. Такая связь необходима в случае, когда поле располагается за пределами <form>, например, при создании её программно или по соображениям дизайна.")
// // let atributs2 = new Atributs('class','Определяет имя класса, которое позволяет связать тег со стилевым оформлением.')
// // let atributs3 = new Atributs('contenteditable','Сообщает, что элемент доступен для редактирования пользователем.')
// // form.addMas(atributs2);
// // form.addMas(atributs3);
// //
// // // -option
// // let option = new Teg("Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.")
// // let atributs2 = new Atributs('disabled','Заблокировать для доступа элемент списка.')
// // let atributs3 = new Atributs('label','Указание метки пункта списка..')
// // option.addMas(atributs2);
// // option.addMas(atributs3);
// // // -select
// // let select = new Teg("Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.")
// // let atributs2 = new Atributs('accesskey','Позволяет перейти к списку с помощью некоторого сочетания клавиш.')
// // let atributs3 = new Atributs('autofocus','Устанавливает, что список получает фокус после загрузки страницы.')
// // select.addMas(atributs2);
// // select.addMas(atributs3);
//
//
// // Приклад результату
// // {
// //     titleOfTag: 'area',
// //         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
// //     attrs: [
// //     {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
// //     {/*some props and values*/},
// //     {/*...*/},
// //     {/*...*/},
// // ]
// //
// // }
// // ==============================================
// //
// //
// //
// // ==============================================
// //     - Створити об'єкт car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// // -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// // -- info () - яка виводить всю інформацію про автомобіль
// // -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// // -- changeYear (newValue) - змінює рік випуску на значення newValue
// // -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// // ==============================================
// //
// // let car = {
// //     model: 'Audi', vyrobnyk: 'Andrey Ivanov', years: 1932, maxSpeed: 999, dvygunV: 1.2, drive: function () {console.log(`їдемо зі швидкістю ${this.maxSpeed} на годину`);}, info: function () {console.log(`model: ${this.model}, years: ${this.years}, maxSpeed: ${this.maxSpeed}, dvygunV: ${this.dvygunV}`)}, increaseMaxSpeed: function (newSpeed) { this.maxSpeed+=newSpeed;}, changeYear: function(newValue){this.years=newValue; }, addDriver:function(driver){
// //         this.driver=driver;
// //     }
// // };
// //
// // let driv = {1: 131123 , lokd: "lokadadads"};
// // car.addDriver(driv);
// // console.log(car);
// //
//
// //
// // ==============================================
// //     - Створити функцію конструктор яка дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// // -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// // -- info () - яка виводить всю інформацію про автомобіль
// // -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// // -- changeYear (newValue) - змінює рік випуску на значення newValue
// // -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// // ==============================================
// //
//
// // let driv = {1: 131123 , lokd: "lokadadads"};
// //
// // function Car(model, madeIn, years, maxSpeed, dvygun) {
// //     this.model = model;
// //     this.madeIn = madeIn;
// //     this.years = years;
// //     this.maxSpeed = maxSpeed;
// //     this.dvygun = dvygun;
// //     this.drive=()=> {console.log(`їдемо зі швидкістю ${this.maxSpeed} на годину`);};
// //     this.info =()=> {console.log(`model: ${this.model}, years: ${this.years}, maxSpeed: ${this.maxSpeed}, dvygunV: ${this.dvygun}`)};
// //     this.increaseMaxSpeed= (newSpeed)=> { this.maxSpeed+=newSpeed;};
// //     this.changeYear= (newValue)=>{this.years=newValue; };
// //     this.addDriver= (driver)=>{  this.driver=driver; }
// // }
// //
// // let car = new Car('Audi','China','2010',200,2.4);
// // car.drive();
// // car.info();
// // car.increaseMaxSpeed(22);
// // car.info();
// // car.changeYear(1111);
// // car.info();
// // car.addDriver(driv);
// // console.log(car);
//
// // ==============================================
// //     - Створити клас який дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// // -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// // -- info () - яка виводить всю інформацію про автомобіль
// // -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// // -- changeYear (newValue) - змінює рік випуску на значення newValue
// // -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// // ==============================================
// //
// //
//
//
// // class Car {
// //     constructor(model, madeIn, years, maxSpeed, dvygun) {
// //         this.model = model;
// //         this.madeIn = madeIn;
// //         this.years = years;
// //         this.maxSpeed = maxSpeed;
// //         this.dvygun = dvygun;
// //     };
// //
// //     drive() {
// //         console.log(`їдемо зі швидкістю ${this.maxSpeed} на годину`)
// //     }
// //
// //     info = () => {
// //         console.log(`model: ${this.model}, years: ${this.years}, maxSpeed: ${this.maxSpeed}, dvygunV: ${this.dvygun}`)
// //     };
// //     increaseMaxSpeed = (newSpeed) => {
// //         this.maxSpeed += newSpeed;
// //     };
// //     changeYear = (newValue) => {
// //         this.years = newValue;
// //     };
// //     addDriver = (driver) => {
// //         this.driver = driver;
// //     }
// // }
// //
// // let car = new Car('Audi','China','2010',200,2.4);
// // car.drive();
// // ==============================================
// //     -створити класс попелюшка з полями ім'я, вік, розмір ноги
// // --Створити 10 попелюшок , покласти їх в масив
// // --Сторити об'єкт класу "принц" за допомоги класу який має поля ім'я, вік, туфелька яку він знайшов.
// // -- за допоиоги циклу знайти яка попелюшка повинна бути з принцом
// // ==============================================
// //
// // class Popelushka {
// //     constructor(name, age, footSize) {
// //         this.name = name;
// //         this.age = age;
// //         this.footSize = footSize;
// //     }
// // }
// // let masPopel=[];
// // for (let i = 0; i < 10; i++) {
// //     masPopel[i]=new Popelushka(`Popelushka${i}`,i+18,i+35);
// // };
// // class Prince{
// // constructor(name,age,shoe) {
// //     this.name=name;
// //     this.age=age;
// //     this.shoe=shoe;
// // }
// // }
// //
// // let prince = new Prince('Patrik',72,38);
// //
// // for (const popel  of masPopel) {
// //     if (popel.footSize===prince.shoe){
// //         console.log('Найшов попилюшку');
// //         console.log(popel);
// //         break;
// //     }
// // }
//
//
// //
// //
// // ==============================================
// //     -створити функцію конструктор попелюшка з полями ім'я, вік, розмір ноги
// // --Створити 10 попелюшок , покласти їх в масив
// // --Сторити об'єкт типу "принц" за допомоги функції конструктора з полями ім'я, вік, туфелька яку він знайшов, та функцію "пошук попелюшки"
// // -- функція повинна приймати масив попелюшок, та шукає ту котра йому підходить
// // ==============================================
// function Popelushka(name, age, footSize) {
//     this.name = name;
//     this.age = age;
//     this.footSize = footSize;
// }
//
// let masPopel = [];
// for (let i = 0; i < 10; i++) {
//     masPopel[i] = new Popelushka(`Popelushka${i}`, i + 18, i + 35);
// }
// ;
//
// function Prince(name, age, shoe) {
//     this.name = name;
//     this.age = age;
//     this.shoe = shoe;
//     this.search = (mas) => {
//         for (const popel of mas) {
//             if (popel.footSize === prince.shoe) {
//                 console.log('Найшов попилюшку');
//                 console.log(popel);
//                 break;
//             }
//
//         }
//     }
//
// }
// let prince = new Prince('Patrik',72,38);
// prince.search(masPopel);
